# Author:  Brian W. DeVries
# Email:   <contingencyplan@gmail.com>, <brian.devries@utdallas.edu>
# License: GNU GPL v3+
# GitHub:  https://github.com/contingencyplan/grading_utilities

"""A library for parsing a submission information file.

Contains the #SubmissionInfo# class, which provides a Python object containing
the contents of the information file. These files can be parsed using the
class methods #SubmissionInfo.from_filename()#, #SubmissionInfo.from_file()#,
#SubmissionInfo.from_string()#, and #SubmissionInfo.from_lines()#. 

Additionally, should the parser encounter an error, a #FormatError# will be
thrown. In general, however, this error should not be encountered unless the
info file has been tampered with; if this error is thrown on a pristine (i.e.,
directly obtained from eLearning) file, then the error should be reported via
the project's GitHub page
(https://github.com/contingencyplan/grading_utilities).


Format
======

The layout of a submission file is as follows:
    
------------------------------------------------------------------------------
Name: <student name> (<student ID>)
Assignment: <assignment name>
Date Submitted: <day>, <month> <date>, <year> <time>
Current Grade: <grade | Not Yet Graded>
Override Grade: <grade | Not Yet Graded>

Submission Field:
<submission text>

Comments:
<comment text>

Files:
        Original filename: <orig filename>
        Filename: <renamed filename>

------------------------------------------------------------------------------

The Override Grade line is optional. All others are mandatory. 

Submission Field may contain the placeholder text "There is no student
submission text data for this assignment." Likewise, Comments may contain
"There are no student comments for this assignment."

The list of files may be empty (denoted by "No files were attached to this
submission.") or contain multiple renames, each followed by a newline.
"""


import re

class SubmissionInfo:
    """The contents of a submission information text file.

    This class contains the contents of a student's submission info text file
    that is automatically generated by eLearning for that particular
    submission.

    To instantiate an instance of this class, #new()# SHOULD NOT be used.
    Instead, the class methods #from_filename()#, #from_file()#,
    #from_string()#, and #from_lines()# SHOULD be used to read the data from a
    a named file, an opened #File# object, a string, or a list of lines
    respectively. 

    If an error is encountered when parsing the file, a
    #FormatError# will be thrown and the instance will not be created.
    There are no facilities for error recovery or attempting to partially
    create an instance of the class from the "good" data. 
     *  NOTE: In general, parsing errors are indicative of an error /
        shortcoming in the parser and should be reported to the author via the
        project's GitHub page.
    
    Currently, no facility is provided to parse a file into an existing
    #SubmissionInfo# instance, to lessen the chances that a #SubmissionInfo#
    instance becomes corrupted with another submission's info. If for some
    reason this leads to excessive memory usage, this can be changed.
    """


    NAME_LINE_RE        = '^Name: (.*)$'
    ASSIGNMENT_NAME_RE  = '^Assignment: (.*)$'
    SUBMISSION_DATE_RE  = '^Date Submitted: (.*)$'
    CURRENT_GRADE_RE    = '^Current Grade: (.*)$'
    OVERRIDE_GRADE_RE   = '^Override Grade: (.*)$'

    SUBMISSION_TEXT_RE  = '^Submission Field:$'
    COMMENTS_RE         = '^Comments:$'
    FILE_RENAMES_RE     = '^Files:$'

    ORIG_FILE_RE        = '^\tOriginal filename: (.*)$'
    RENAMED_FILE_RE     = '^\tFilename: (.*)$'

    
    # Placeholder texts
    GRADE_TEXT_PLACEHOLDER = \
            "Not Yet Graded"

    SUBMISSION_TEXT_PLACEHOLDER = \
            "There is no student submission text data for this assignment."

    COMMENTS_PLACEHOLDER = \
            "There are no student comments for this assignment."

    FILES_PLACEHOLDER = \
            "No files were attached to this submission."
            


    def __init__(self,
                 name,
                 assignment_name,
                 submission_date,
                 current_grade,
                 override_grade,
                 submission_text,
                 comments,
                 file_renames
                ):
        """Creates an instance of this class from the data values.
        
        Clients of this class SHOULD NOT use this method to instantiate
        this class, as no parsing is actually performed here. Use
        #from_filename()#, #from_file()#, #from_string()#, or #from_lines()#
        instead.
        """

        self.name            = name
        self.assignment_name = assignment_name
        self.submission_date = submission_date
        self.current_grade   = current_grade
        self.override_grade  = override_grade
        self.submission_text = submission_text
        self.comments        = comments
        self.file_renames    = file_renames


    @classmethod
    def from_filename(cls, filename):
        """Create a new instance by parsing the contents of #filename#.

        If the file does not exist, then the resulting #IOError# is not caught
        here, instead being thrown to the caller.
        """

        with open(filename, "rU") as f:
            return cls.from_file(f)


    @classmethod
    def from_file(cls, f):
        """Create a new instance by parsing the contents of the #File# #f#.

        Any I/O errors that occur are not caught here, instead being thrown to
        the caller.

        It is recommended that the file be opened with "Universal Newlines"
        support, as no attempt is made here to handle different newlines
        (i.e., #\\n# is always used). See
        http://docs.python.org/2/library/functions.html#open .
        """

        # We just dump the whole file into a string, since they're pretty
        # small.
        lines = f.readlines()
        return cls.from_lines(lines)


    @classmethod
    def from_string(cls, s):
        """Create a new instance by parsing the provided string #s#.
        """

        lines = s.splitlines()
        return cls.from_lines(lines)


    @classmethod
    def from_lines(cls, lines):
        """Create a new instance by parsing the list of #lines#.
        """

        # Begin by stripping any trailing whitespace from the lines.
        lines = [l.rstrip() for l in lines]

        i = 0

        # The first line should be the student's name.
        name_text, i = \
                cls.__parse_line(cls.NAME_LINE_RE, 
                                 "Name", i, lines
                                )

        name = name_text.group(1)

        # Now handle the assignment name
        assignment_name_text, i = \
                cls.__parse_line(cls.ASSIGNMENT_NAME_RE, 
                                 "Assignment", i, lines
                                )

        assignment_name = assignment_name_text.group(1)
        
        # Parse the submission date line
        submission_date_text, i = \
                cls.__parse_line(cls.SUBMISSION_DATE_RE, 
                                 "Date Submitted", i, lines
                                )

        submission_date = submission_date_text.group(1)

        # Parse the current grade
        current_grade_text, i = \
                cls.__parse_line(cls.CURRENT_GRADE_RE, 
                                 "Current Grade", i, lines
                                )

        current_grade = current_grade_text.group(1)

        # Parse the optional Override Grade

        override_grade_text, i = \
                cls.__parse_line(cls.OVERRIDE_GRADE_RE,
                                 "Override Grade", i, lines,
                                 optional = True
                                )

        if override_grade_text != None:
            override_grade = override_grade_text.group(1)
        else:
            override_grade = None

        # Parse the submission text block
        submission_text_lines, i = \
                cls.__parse_block(cls.SUBMISSION_TEXT_RE,
                                  cls.COMMENTS_RE,
                                  "Submission Field", i, lines
                                 )

        submission_text = cls.__combine_block(submission_text_lines,
                                              cls.SUBMISSION_TEXT_PLACEHOLDER
                                             )

        # Parse the comments block
        comments_lines, i = \
                cls.__parse_block(cls.COMMENTS_RE,
                                  cls.FILE_RENAMES_RE,
                                  "Comments", i, lines
                                 )

        comments = cls.__combine_block(comments_lines,
                                       cls.COMMENTS_PLACEHOLDER
                                      )

        # Parse the file renames block. This should be the last thing in the
        # file.
        #
        # Because of the structure of this block (namely, we want to parse its
        # contents, not just omnom all of the text), we do not use
        # #__parse_block#.
        _files_line, i = cls.__parse_line(cls.FILE_RENAMES_RE,
                                          "Files", i, lines
                                         )

        # Process the file renames 
        file_renames, i = cls.__process_renames(i, lines)

        # If we've done everything right, we should be at the end of the file.
        assert i == len(lines)


        return cls(name, 
                   assignment_name, 
                   submission_date,
                   current_grade,
                   override_grade,
                   submission_text,
                   comments,
                   file_renames
                  )


    @classmethod
    def __process_renames(cls, i, lines):
        """Processes the lines starting at #i# into a file rename mapping.

        The expected format of a file rename is 3 lines:
         1.  The original filename
         2.  The renamed filename
         3.  A blank line.

        These renames should represent a bijection between the two sets of
        strings representing the filenames.

        Alternatively, the only remaining line may be #FILES_PLACEHOLDER#,
        indicating that no renames are present. 

        A dictionary from the provided renames to the original files are
        returned, along with the updated value of #i#. Because this dictionary
        represents a bijection, it is straightforward to create a dictionary
        in the opposite direction if necessary.

        A #FormatError# MUST be thrown if the sequence of lines does not
        conform to this expected format (either a sequence of renames or the
        #FILES_PLACEHOLDER# string).

        @precondition 0 <= i <= len(lines)

        """

        assert 0 <= i <= len(lines)

        renames = {}

        # Check for the placeholder string
        if i != len(lines):
            if lines[i] == cls.FILES_PLACEHOLDER:
                i += 1

            else:
                # We should have a set of renames, so process them

                # Invariant:
                #   Let I = i @ now
                #   << forall k  :  0 <= I + k * 3 < i  :
                #       the k'th file rename has been inserted into renames >>
                #
                # Termination:
                #   i is MIBA by len(file_renames_list)
                while i != len(lines):
                    orig_file_text, i = \
                            cls.__parse_line(cls.ORIG_FILE_RE,
                                             "Original filename", i, lines
                                            )

                    orig_file = orig_file_text.group(1)

                    # Make sure that #orig_file# is fresh
                    if orig_file in renames.values():
                        raise FormatError(i, 
                                          "New original filename", 
                                          lines[i - 1]
                                         )
                    
                    # Note that we do not bounds check here, as #__parse_line#
                    # will throw an error if we hit EOF prematurely. Perhaps
                    # not the best style, but it works.
                    renamed_file_text, i = \
                            cls.__parse_line(cls.RENAMED_FILE_RE,
                                             "Renamed filename", 
                                             i, lines
                                            )

                    renamed_file = renamed_file_text.group(1)

                    # Make sure that #renamed_file# is fresh
                    if renamed_file in renames:
                        raise FormatError(i, 
                                          "New renamed filename", 
                                          lines[i - 1]
                                         )

                    # If the third line is blank, then ignore it; otherwise
                    # raise an error.
                    i = cls.__parse_empty_line("Empty line after file rename", 
                                               i, lines
                                              )

                    # We're good; add the rename mapping
                    renames[renamed_file] = orig_file

        return renames, i



    @classmethod
    def __next_nonempty_line(cls, lines, i = 0):
        """Utility function that returns the index of the next nonempty line.

        The optional parameter #i# provides the index to begin counting from. If
        all remaining lines are empty, then #len(lines)# is returned.

        @precondition 0 <= i < len(lines)
        """

        assert(0 <= i < len(lines))

        # Invariant:
        #   Let I = i @ now
        #   << forall k : I <= k < i : len(lines[k]) == 0 >>
        # 
        # Termination:
        #   i is MIBA by len(lines)
        while i != len(lines) and len(lines[i]) == 0:
            i += 1

        return i

    @classmethod
    def __parse_line(cls,
                     regex, 
                     expected, 
                     i, 
                     lines, 
                     optional      = False,
                     ignore_blanks = True
                    ):
        """Parse a single-line entry according to #regex#.

        If #ignore_blanks# is #True#, then preceeding empty lines are ignored;
        the first non-empty line must match the #regex#. Otherwise, #lines[i]#
        must itself match the #regex#.
        
        The resulting #MatchObject# is returned, along with the updated value
        for #i# (in this case #i + 1#).

        If #optional# is #False#, a #FormatError# MUST be thrown if the first
        considered line does not match #regex# or if the line number #i# is at
        the end of the list of #lines#. #expected# holds the expected value
        for use in throwing this exception.

        If #optional# is #True# and parsing the first considered line fails
        (for either of the above reasons), then the match of #None# and the
        original value of #i# are returned; in particular, the ignoring of
        preceeding blank lines is not reflected in the returned #i# in this
        case.

        @precondition 0 <= i <= len(lines)
        """

        assert 0 <= i <= len(lines)

        orig_i = i

        # Skip empty lines. 
        # NOTE: This may be a bit too general.
        if ignore_blanks:
            i = cls.__next_nonempty_line(lines, i)

        if i != len(lines):
            ret = re.match(regex, lines[i])
            i += 1

            if ret == None:
                if not optional:
                    raise FormatError(i + 1, expected, lines[i])
                else:
                    i = orig_i


        elif not optional:
            raise FormatError(len(lines), expected, "end of file")

        return (ret, i)


    @classmethod
    def __parse_empty_line(cls, expected, i, lines, optional = False):
        """Parse an empty line.

        This is a convenience method. Since we automatically ignore blank
        lines with #__parse_line#, we cannot use this to detect that we
        actually have an explicit blank line.

        If #optional# is #False#, a #FormatError# MUST be thrown if the line
        at #i# is not blank or if #i# is at the end of the list. #expected#
        holds the expected value information for use in throwing this
        exception.

        If #optional# is #True# and parsing the blank line fails (for either
        of the above reasons), the original value of #i# is returned.

        Because there is no useful information from this parse, we only return
        the updated value of #i#.
        """

        assert 0 <= i <= len(lines)

        if i != len(lines):
            if len(lines[i]) == 0:
                i += 1

            elif not optional:
                raise FormatError(i + 1, expected, lines[i])

        elif not optional:
            raise FormatError(i + 1, expected, "end of file")

        return i



    @classmethod
    def __parse_block(cls,
                      start_regex, 
                      end_regex, 
                      expected, 
                      i, 
                      lines,
                      optional      = False,
                      end_optional  = False,
                      ignore_blanks = True
                     ):
        """Parse a block entry according to the start and end regexes.

        #start_regex# is the regex declaring the start of the block. It is
        expected that this regex does not require keeping any information from
        the match (i.e., it is just a header, and the line matching the regex
        does not contain any important information). 

        All lines after the #start_regex# and before the #end_regex# are
        returned, along with the value of #i# equal to the line on which
        #end_regex# occurs. Similarly to #start_regex#, it is assumed that
        #end_regex# occurs on its own line and that no useful information also
        occurs on that line.

        Note that the first considered line is not checked for #end_regex#, so
        if #start_regex# and #end_regex# are the same, they must occur on two
        separate lines.

        If #ignore_blanks# is #True#, then any preceeding blank lines are
        ignored; the first non-empty line must match #start_regex#. Otherwise,
        #lines[i]# must itself match #start_regex#.

        If #optional# is #True#, then the first considered line may be at the
        end of #lines# or it may fail to match #start_regex# without being
        considered an error. An empty list and the original value of #i# are
        returned in this case; this value of #i# does not reflect any ignoring
        of preceeding blank lines.

        If #end_optional# is #True#, then #end_regex# may fail to match any
        subsequent lines without being considered an error. Similarly, if
        #end_regex# is #None#, then the block is considered to extend to the
        end of #lines#. In such cases, all lines after the #start_regex# are
        returned along with #len(lines)#.
        
        Because we are only checking regexes for each line, this will
        obviously not handle nested constructs. This should be fine, as the
        format does not appear to employ them.

        A #FormatError# MUST be thrown in the following circumstances:
         *  The first considered line does not match #start_regex# or #i# is
            at the end of #lines#, unless #optional# is #True#
         
         *  The end of the list is encountered before #end_regex# is matched,
            unless #end_optional# is #True# or #end_regex# is the empty
            string.

        @precondition 0 <= i <= len(lines)
        """

        assert 0 <= i <= len(lines)

        j = i

        # Skip empty lines.
        # NOTE: This may be a bit too general.
        if ignore_blanks:
            i = cls.__next_nonempty_line(lines, i)

        if i != len(lines):
            if re.match(start_regex, lines[i]):
                i = i + 1
                j = i

                # We matched the start. Check whether we want the rest of the
                # lines or we need to check for #end_regex#.
                if end_regex == None:
                    ret = lines[i:]
                    j = len(lines)

                else:
                    # We are now checking for #end_regex#.
                    # Invariant:
                    #   Let J = j @ now
                    #   << forall k : J <= k < j : 
                    #       lines[k] does not match end_regex >>
                    #
                    # Termination:
                    #   j is MIBA by len(lines)
                    while     j != len(lines)  \
                          and not re.match(end_regex, lines[j]):
                        j += 1

                    # Either we are at the end of lines, xor we found a match.
                    if j == len(lines) and not end_optional:
                        raise FormatError(j, 
                                          expected + " (end from %i)" % i, 
                                          "end of file"
                                         )
                    else:
                        ret = lines[i:j]

            elif not optional:
                # We failed to match the regex on the current line.
                raise FormatError(i + 1, expected, lines[i])

        elif not optional:
            # We are past the end of the file.
            raise FormatError(len(lines), expected, "end of file")


        return ret, j
    

    @classmethod
    def __combine_block(cls, block_lines, blank_placeholder = ''):
        """Combine the lines obtained by parsing a text block.

        Any trailing whitespace is removed from the resulting string (though
        empty lines in the middle of the sequence are preserved.

        If the optional #blank_placeholder# is non-empty, then the resulting
        text is compared to #blank_str#. If they match, then the empty string
        is returned. This way clients of the class can easily tell whether
        there was any actual information in the block without having to
        compare with the placeholder themselves.
        """

        ret = '\n'.join(block_lines).rstrip()
        if ret == blank_placeholder:
            ret = ''

        return ret

    

class FormatError(Exception):
    """Indicates a formatting error in the submission info text file.

    This exception is thrown when the parser encounters information that it's
    not expecting (or more accurately, when it doesn't encounter something it
    *was* expecting). 

    In general, unless the file has been manipulated after downloading, this
    exception should never occur in practice. If it does, then please let the
    author know via the project's GitHub page so the parser can be updated.
    """

    def __init__(self, line_num, expected, line):
        """Indicate that an error occurred on #lineNum#.

        #expected# is a string indicating what value / line was expected, and
        #line# is the line that the error occurred on. 
        
        NOTE: #lineNum# MUST count from origin 1, not 0, to match the
        behavior of most editors.
        """

        Exception.__init__(self)
        self.line_num    = line_num
        self.expected   = expected
        self.line       = line


    def __str__(self):
        """Provide a generic error message string for the error.

        This makes it easy to print an error message to the User, if desired.
        """

        return "ERROR (Line %i): Expected %s\nFound: %s" \
                % (self.line_num, self.expected, self.line)





        


